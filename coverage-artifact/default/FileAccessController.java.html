<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileAccessController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pa-web-server</a> &gt; <a href="index.source.html" class="el_package">default</a> &gt; <span class="el_source">FileAccessController.java</span></div><h1>FileAccessController.java</h1><pre class="source lang-java linenums">import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * The FileAccessController class manages thread-safe file access operations for the HTTP server.
 * &lt;p&gt;
 * This class implements a file locking mechanism to prevent concurrent modifications and
 * path transversal attacks. It maintains a map of file locks to ensure exclusive access
 * to files during read operations using ReentrantLock with fair ordering policy.
 * &lt;p&gt;
 * The locking mechanism includes timeout protection to prevent deadlocks. Each file
 * path has its own dedicated lock object managed in a concurrent hash map.
 *
 * @see ReentrantLock
 * @see ConcurrentHashMap
 */

public class FileAccessController {

<span class="fc" id="L25">    private static final ConcurrentHashMap&lt;String, ReentrantLock&gt; fileLocks = new ConcurrentHashMap&lt;&gt;();</span>
    private final ServerConfig config;
    private static final long LOCK_TIMEOUT_SECONDS = 5;

    /**
     * Constructs a new FileAccessController with the specified server configuration.
     * &lt;p&gt;
     * The configuration object must contain valid server root directory and default page settings.
     * The controller will use these settings for all file access operations.
     *
     * @param config the ServerConfig object containing server configuration parameters.
     */

<span class="fc" id="L38">    public FileAccessController(ServerConfig config) {</span>
<span class="fc" id="L39">        this.config = config;</span>
<span class="fc" id="L40">    }</span>

    /**
     * Reads a file from the server's root directory with a thread-safe access control.
     * &lt;p&gt;
     * This method performs several security checks and operations in sequence:
     * Validates the requested path against the server root to prevent path traversal.
     * Acquires an exclusive lock for the life with timeout.
     * Verifies file existence and type.
     * Reads file contents and releases the lock and cleans up.
     * &lt;p&gt;
     * Lock acquisition follows strict first-come-first-served ordering due to fair locking.
     * The method guarantees lock release even if an exception occurs during the file reading.
     *
     * @param route the relative path of the file to read from server root
     *              If null or empty, defaults to configured default page.
     * @return byte array containing the file contents
     * @throws IOException if path traversal attempt is detected,
     * file is not found,
     * path is a directory,
     * timeout occurs while waiting for file lock or
     * general I/O error occurs during reading
     *
     * @throws InterruptedException if the thread is interrupted while waiting for the lock
     */

    public byte[] readFile(String route) throws IOException, InterruptedException {
<span class="fc" id="L67">        Path rootPath = Paths.get(config.getConfig(&quot;server.root&quot;)).toAbsolutePath().normalize();</span>

<span class="pc bpc" id="L69" title="2 of 4 branches missed.">        if (route == null || route.isEmpty()) {</span>
<span class="nc" id="L70">            route = &quot;/&quot; + config.getConfig(&quot;server.default.page&quot;) +</span>
<span class="nc" id="L71">                    &quot;.&quot; + config.getConfig(&quot;server.default.page.extension&quot;);</span>
        }

<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (route.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L75">            route = route.substring(1);</span>
        }

<span class="fc" id="L78">        Path requestedPath = Paths.get(route).normalize();</span>
<span class="fc" id="L79">        Path filePath = rootPath.resolve(requestedPath).toAbsolutePath().normalize();</span>

<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if (!filePath.startsWith(rootPath)) {</span>
<span class="nc" id="L82">            String errorMsg = String.format(</span>
                    &quot;Access denied: Path traversal attempt. Requested '%s' is outside server root '%s'&quot;,
                    filePath, rootPath);
<span class="nc" id="L85">            System.err.println(&quot;Security violation: &quot; + errorMsg);</span>
<span class="nc" id="L86">            throw new IOException(errorMsg);</span>
        }

<span class="fc" id="L89">        ReentrantLock fileLock = fileLocks.computeIfAbsent(</span>
<span class="fc" id="L90">                filePath.toString(),</span>
<span class="fc" id="L91">                k -&gt; new ReentrantLock(true)</span>
        );

<span class="fc" id="L94">        System.out.printf(&quot;[%s] Trying to acquire lock for: %s (Queued threads: %d)%n&quot;,</span>
<span class="fc" id="L95">                Thread.currentThread().getName(),</span>
                filePath,
<span class="fc" id="L97">                fileLock.getQueueLength());</span>

<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (!fileLock.tryLock(LOCK_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L100">            System.err.printf(&quot;[%s] Timeout when waiting for lock: %s%n&quot;,</span>
<span class="nc" id="L101">                    Thread.currentThread().getName(),</span>
                    filePath);
<span class="nc" id="L103">            throw new IOException(&quot;Timeout waiting for file access: &quot; + filePath);</span>
        }

        try {
<span class="fc" id="L107">            System.out.printf(&quot;[%s] Lock acquired for: %s (Time on the system: %dns)%n&quot;,</span>
<span class="fc" id="L108">                    Thread.currentThread().getName(),</span>
                    filePath,
<span class="fc" id="L110">                    System.nanoTime());</span>

<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (!Files.exists(filePath)) {</span>
<span class="nc" id="L113">                throw new IOException(&quot;File not found: &quot; + filePath);</span>
            }
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (Files.isDirectory(filePath)) {</span>
<span class="nc" id="L116">                throw new IOException(&quot;Path is a directory: &quot; + filePath);</span>
            }

<span class="fc" id="L119">            Thread.sleep(100);</span>

<span class="fc" id="L121">            return Files.readAllBytes(filePath);</span>
        } finally {
<span class="fc" id="L123">            System.out.printf(&quot;[%s] Releasing lock: %s (Tempo no sistema: %dns)%n&quot;,</span>
<span class="fc" id="L124">                    Thread.currentThread().getName(),</span>
                    filePath,
<span class="fc" id="L126">                    System.nanoTime());</span>

<span class="fc bfc" id="L128" title="All 2 branches covered.">            if (!fileLock.hasQueuedThreads()) {</span>
<span class="fc" id="L129">                fileLocks.remove(filePath.toString(), fileLock);</span>
            }
<span class="fc" id="L131">            fileLock.unlock();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>